package generate

import (
	"fmt"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"
)

type (
	ElsaGenFile struct {
		Target           string
		PackageName      string
		ImportedPackages map[string]ElsaImportedPackages
		StructsData      map[string][]StructFieldInfo
		Functions        map[string]ElsaGenFunction
		FuncGenerated    map[string][]FuncInfo
		Sets             map[string][]FuncInfo
	}

	ElsaImportedPackages struct {
		Alias    string
		UseAlias bool
	}

	ElsaGenFunction struct {
		SourcePackages map[string]ElsaSourceDetail
		Params         []TypeInfo
		Results        []TypeInfo
	}

	ElsaSourceDetail struct {
		VariableName string
		UsePointer   bool
	}
)

// processGenerateDependencies processes a single file for generation dependencies.
// This function is the main entry point for processing Go files that contain elsa.Generate calls.
// It extracts functions with elsa.Generate calls, analyzes elsa.Set declarations,
// and loads constructor information for the found functions.
// Returns an error if the processing fails at any step.
func (g *Generator) processGenerateDependencies(target string) error {
	// Initialize and validate dependencies
	elsaGenFile, err := g.initializeElsaGenFile(target)
	if err != nil {
		return err
	}

	// Generate the final file
	return g.GenerateElsaGenFile(target, *elsaGenFile)
}

// GenerateElsaGenFile generates an elsa_gen.go file for the target.
// This function creates the final generated file with all the processed content.
// It validates the generated Go code before writing to ensure syntax correctness.
// It writes the generated content to a file named elsa_gen.go in the same directory as the target.
// The package name is extracted from the target file and used in the generated file.
// Returns an error if validation fails or file writing fails.
func (g *Generator) GenerateElsaGenFile(target string, elsaGenFile ElsaGenFile) error {
	// Generate the content for elsa_gen.go
	content := g.generateElsaGenContent(elsaGenFile)

	// Validate the generated Go code
	if err := g.validateGoCode(content); err != nil {
		return fmt.Errorf("generated code validation failed: %v", err)
	}

	// Determine the output path (same directory as target)
	outputDir := filepath.Dir(target)
	outputPath := filepath.Join(outputDir, "elsa_gen.go")

	// Write the generated file
	err := os.WriteFile(outputPath, []byte(content), 0644)
	if err != nil {
		return fmt.Errorf("failed to write elsa_gen.go: %v", err)
	}

	fmt.Printf("Generated: %s from %s\n", outputPath, elsaGenFile.Target)
	return nil
}

// generateElsaGenHeader generates the standard header for elsa_gen.go files.
// This function creates the header section that includes build tags and generation directives.
// The header contains comments indicating the file is generated and should not be edited manually.
// It also includes go:generate and go:build directives for proper build integration.
func (g *Generator) generateElsaGenHeader() string {
	return `// Code generated by Elsa. DO NOT EDIT.

//go:generate go run -mod=mod github.com/risoftinc/elsa/cmd/elsa gen
//go:build !elsabuild
// +build !elsabuild

`
}

// generateElsaGenContent generates the complete content for elsa_gen.go file.
// This function orchestrates the generation of all file sections including header,
// package declaration, imports, structs, and functions.
// It combines all generated content into a single string that represents the complete file.
// The content includes generation timestamp and source file information.
func (g *Generator) generateElsaGenContent(elsaGenFile ElsaGenFile) string {
	var content string

	// Add header
	content += g.generateElsaGenHeader()

	// Add package declaration
	content += fmt.Sprintf("package %s\n\n", elsaGenFile.PackageName)

	// Add Import Selection
	content += g.generateElsaGenImportSelection(elsaGenFile)

	// Inject From
	content += fmt.Sprintf("// This file generated from %s at %s\n\n",
		getNameFile(elsaGenFile.Target), time.Now().Format(time.RFC3339),
	)

	// Add Structs
	content += g.generateElsaGenStructs(elsaGenFile)

	// Add Functions
	content += g.generateElsaGenFunctions(elsaGenFile)

	return content
}

// generateElsaGenImportSelection generates the import section for the generated file.
// This function creates the import block with all necessary package imports.
// It filters out built-in types and struct data packages to avoid unnecessary imports.
// The imports are sorted alphabetically for consistent ordering and readability.
// Returns the formatted import section as a string.
func (g *Generator) generateElsaGenImportSelection(elsaGenFile ElsaGenFile) string {
	content := "import (\n\t\"github.com/risoftinc/elsa\"\n\n"

	// Convert map to slice for consistent ordering
	var packages []string
	for pkg := range elsaGenFile.ImportedPackages {
		if pkg == "" || isBuiltinType(pkg) {
			continue
		}
		if _, ok := elsaGenFile.StructsData[pkg]; ok {
			continue
		}
		importedPackage := elsaGenFile.ImportedPackages[pkg]
		packages = append(packages, fmt.Sprintf("\t%s \"%s\"\n", importedPackage.Alias, pkg))
	}

	// Sort packages alphabetically for consistent order
	sort.Strings(packages)

	// Generate imports in sorted order
	for _, pkg := range packages {
		content += pkg
	}

	return content + ")\n\n"
}

// generateElsaGenStructs generates struct definitions for the generated file.
// This function creates Go struct type definitions based on the struct data collected.
// It handles proper field alignment by calculating the maximum field name length.
// Each struct field is formatted with appropriate padding for clean code generation.
// Returns the formatted struct definitions as a string.
func (g *Generator) generateElsaGenStructs(elsaGenFile ElsaGenFile) string {
	content := ""
	for pkg, structs := range elsaGenFile.StructsData {
		content += fmt.Sprintf("type %s struct {\n", pkg)

		// Find the maximum field name length for alignment
		maxNameLength := 0
		for _, structData := range structs {
			if len(structData.Name) > maxNameLength {
				maxNameLength = len(structData.Name)
			}
		}

		// Generate struct fields with proper alignment
		for _, structData := range structs {
			et := extractType(structData.Type)

			var typeName string
			if et.Package == "" {
				// Builtin type, use DataType directly
				typeName = et.DataType
			} else {
				// Custom type, use alias + DataType
				typeName = elsaGenFile.ImportedPackages[et.Package].Alias + "." + et.DataType
			}

			// Create padding spaces for alignment
			padding := strings.Repeat(" ", maxNameLength-len(structData.Name))
			content += fmt.Sprintf("\t%s%s %s\n", structData.Name, padding, typeName)
		}
		content += "}\n\n"
	}
	return content
}

// generateElsaGenFunctions generates all function definitions for the generated file.
// This function iterates through all functions in the ElsaGenFile and generates
// their complete definitions including parameters, return types, and function bodies.
// It delegates the actual function generation to generateSingleFunction for each function.
// Returns the concatenated function definitions as a string.
func (g *Generator) generateElsaGenFunctions(elsaGenFile ElsaGenFile) string {
	content := ""
	for name, function := range elsaGenFile.Functions {
		content += g.generateSingleFunction(name, function, elsaGenFile)
	}
	return content
}

// generateSingleFunction generates a complete function definition with all its components.
// This function creates a single function with its signature (parameters and return types)
// and complete function body including generated function calls and return statements.
// It orchestrates the generation of function parameters, results, and body content.
// Returns the complete function definition as a formatted string.
func (g *Generator) generateSingleFunction(name string, function ElsaGenFunction, elsaGenFile ElsaGenFile) string {
	// Generate function signature
	params := g.generateFunctionParams(function, elsaGenFile)
	results := g.generateFunctionResults(function)
	returnStr := g.formatReturnTypes(results)

	content := fmt.Sprintf("func %s(%s) %s {\n", name, strings.Join(params, ", "), returnStr)

	// Generate function body
	content += g.generateFunctionBody(name, function, elsaGenFile)
	content += "}\n\n"

	return content
}

// generateFunctionParams generates the parameter list for a function signature.
// This function processes all function parameters and formats them with proper types.
// It handles pointer types, imported packages, and built-in types appropriately.
// The parameters are formatted as "variableName type" pairs for the function signature.
// Returns a slice of formatted parameter strings.
func (g *Generator) generateFunctionParams(function ElsaGenFunction, elsaGenFile ElsaGenFile) []string {
	var params []string
	for _, param := range function.Params {
		var typeName string
		var variableName string

		if param.Package == "" {
			// Builtin type
			typeName = param.DataType
			if param.UsePointer {
				typeName = "*" + typeName
			}
			// For builtin types, use the parameter name directly
			variableName = param.ParamName
		} else {
			// Custom type
			importedPackage := elsaGenFile.ImportedPackages[param.Package].Alias
			if param.UsePointer {
				importedPackage = "*" + importedPackage
			}
			if _, ok := elsaGenFile.StructsData[param.Package]; !ok {
				importedPackage += "." + param.DataType
			}
			typeName = importedPackage

			// Get variable name from SourcePackages
			key := param.Package + "." + param.DataType
			variableName = function.SourcePackages[key].VariableName
		}

		paramStr := fmt.Sprintf("%s %s", variableName, typeName)
		params = append(params, paramStr)
	}
	return params
}

// generateFunctionResults generates the return type list for a function signature.
// This function processes all function return types and formats them appropriately.
// It handles pointer types by adding the asterisk (*) prefix when needed.
// The return types are formatted as type names for the function signature.
// Returns a slice of formatted return type strings.
func (g *Generator) generateFunctionResults(function ElsaGenFunction) []string {
	var results []string
	for _, result := range function.Results {
		resultType := result.Package
		if result.UsePointer {
			resultType = "*" + resultType
		}
		results = append(results, resultType)
	}
	return results
}

// formatReturnTypes formats the return type string for function signatures.
// This function handles single and multiple return types appropriately.
// For single return type, it returns the type as-is.
// For multiple return types, it wraps them in parentheses for proper Go syntax.
// Returns the formatted return type string.
func (g *Generator) formatReturnTypes(results []string) string {
	returnStr := strings.Join(results, ", ")
	if len(results) > 1 {
		returnStr = "(" + returnStr + ")"
	}
	return returnStr
}

// generateFunctionBody generates the complete function body with all necessary components.
// This function creates the function body including calls to generated functions,
// elsa.Generate call, and return statement with proper struct initialization.
// It processes all generated functions and collects their return variables.
// Returns the complete function body as a formatted string.
func (g *Generator) generateFunctionBody(name string, function ElsaGenFunction, elsaGenFile ElsaGenFile) string {
	var content string
	var elsaGeneratedVariables []string

	// Generate calls to generated functions
	for _, generated := range elsaGenFile.FuncGenerated[name] {
		callContent, variables := g.generateFunctionCall(generated, function, elsaGenFile)
		content += callContent
		elsaGeneratedVariables = append(elsaGeneratedVariables, variables...)
	}

	// Add elsa.Generate call
	content += fmt.Sprintf("\n\telsa.Generate(%s)\n", strings.Join(elsaGeneratedVariables, ", "))

	// Generate return statement
	content += g.generateReturnStatement(function, elsaGenFile)

	return content
}

// generateFunctionCall generates a function call statement for a generated function.
// This function creates the complete function call including parameter formatting
// and return variable assignment. It handles pointer dereferencing and referencing
// based on the parameter and source types. Returns the call statement and result variables.
// Returns the formatted function call string and a slice of result variable names.
func (g *Generator) generateFunctionCall(generated FuncInfo, function ElsaGenFunction, elsaGenFile ElsaGenFile) (string, []string) {
	importedPackage := elsaGenFile.ImportedPackages[generated.PkgPath].Alias
	var params, results []string

	// Generate parameters
	for _, param := range generated.Params {
		et := extractType(param.Type)
		source := function.SourcePackages[et.Package+"."+et.DataType]
		paramValue := g.formatParameterValue(source, et)
		params = append(params, paramValue)
	}

	// Generate results
	for _, result := range generated.Results {
		et := extractType(result.Type)
		resultVar := function.SourcePackages[et.Package+"."+et.DataType].VariableName
		results = append(results, resultVar)
	}

	callContent := fmt.Sprintf("\t%s := %s.%s(%s)\n",
		strings.Join(results, ", "),
		importedPackage,
		generated.FuncName,
		strings.Join(params, ", "))

	return callContent, results
}

// formatParameterValue formats a parameter value based on pointer type requirements.
// This function handles the conversion between pointer and value types when passing parameters.
// It adds dereference (*) or reference (&) operators as needed to match type requirements.
// The formatting ensures type compatibility between source and target parameter types.
// Returns the properly formatted parameter value string.
func (g *Generator) formatParameterValue(source ElsaSourceDetail, et TypeInfo) string {
	if source.UsePointer == et.UsePointer {
		return source.VariableName
	} else if et.UsePointer && !source.UsePointer {
		return "*" + source.VariableName
	} else {
		return "&" + source.VariableName
	}
}

// generateReturnStatement generates the return statement for a function.
// This function creates the return statement with proper struct initialization if needed.
// It handles pointer types by adding the reference operator (&) when required.
// For struct types, it generates struct literal initialization with field assignments.
// Returns the formatted return statement string.
func (g *Generator) generateReturnStatement(function ElsaGenFunction, elsaGenFile ElsaGenFile) string {
	content := "\treturn "
	for idx, result := range function.Results {
		if idx > 0 {
			content += ", "
		}
		// Generate struct content if needed
		structContent := g.generateStructContent(result, function, elsaGenFile)

		// Generate return value based on type
		if structContent != "" {
			// For struct types, use struct literal
			if result.UsePointer {
				content += "&" + result.Package + structContent
			} else {
				content += result.Package + structContent
			}
		} else {
			// For non-struct types, we need to return a variable name or default value
			// Find the variable name from source packages
			key := fmt.Sprintf("%s.%s", result.Package, result.DataType)
			if source, exists := function.SourcePackages[key]; exists {
				content += source.VariableName
			} else {
				// Fallback: return default value based on type
				content += g.getDefaultValueForType(result)
			}
		}
	}
	content += "\n"
	return content
}

// generateStructContent generates struct literal initialization content.
// This function creates the struct initialization block with field assignments.
// It maps struct fields to their corresponding source variables from the function.
// The struct literal is formatted with proper indentation and field assignments.
// Returns the formatted struct initialization string, empty if not a struct type.
func (g *Generator) generateStructContent(result TypeInfo, function ElsaGenFunction, elsaGenFile ElsaGenFile) string {
	structContent := ""
	if structFields, exists := elsaGenFile.StructsData[result.Package]; exists {
		for _, structData := range structFields {
			// Check if this is a builtin type
			et := extractType(structData.Type)
			var variableName string

			if et.Package == "" {
				// Builtin type, look for matching parameter in function
				key := fmt.Sprintf("%s.%s", et.Package, et.DataType) // This will be ".string"
				if source, exists := function.SourcePackages[key]; exists {
					variableName = source.VariableName
				} else {
					// Fallback to default value
					variableName = g.getDefaultValueForType(et)
				}
			} else {
				// Custom type, look up in SourcePackages
				key := fmt.Sprintf("%s.%s", et.Package, et.DataType)
				if source, exists := function.SourcePackages[key]; exists {
					variableName = source.VariableName
				} else {
					// Fallback to default value
					variableName = g.getDefaultValueForType(et)
				}
			}

			structContent += fmt.Sprintf("\t\t%s: %s,\n",
				structData.Name,
				variableName)
		}
		if structContent != "" {
			structContent = "{\n" + structContent + "\t}"
		}
	}
	return structContent
}

// initializeElsaGenFile initializes the ElsaGenFile structure with basic data.
// This function sets up the main data structure for code generation by extracting
// functions with elsa.Generate calls and parsing elsa.Set declarations.
// It validates that at least one function with elsa.Generate is found.
// Returns a pointer to the initialized ElsaGenFile or an error if initialization fails.
func (g *Generator) initializeElsaGenFile(target string) (*ElsaGenFile, error) {
	goModDir, err := g.FindGoModDir(target)
	if err != nil {
		return nil, err
	}

	// Extract functions containing elsa.Generate
	funcs, err := g.ExtractElsaGenerateFuncs(target)
	if err != nil {
		return nil, err
	}

	if len(funcs) == 0 {
		return nil, fmt.Errorf("no functions with elsa.Generate calls found")
	}

	sets, err := g.ParseElsaSets(goModDir, target)
	if err != nil {
		return nil, err
	}

	elsaGenFile := &ElsaGenFile{
		Target:           target,
		PackageName:      funcs[0].PkgName,
		ImportedPackages: make(map[string]ElsaImportedPackages),
		StructsData:      make(map[string][]StructFieldInfo),
		Functions:        make(map[string]ElsaGenFunction),
		FuncGenerated:    make(map[string][]FuncInfo),
		Sets:             sets,
	}

	// Process each function
	for _, fn := range funcs {
		if err := g.processFunction(elsaGenFile, fn); err != nil {
			return nil, err
		}
	}

	return elsaGenFile, nil
}

// processFunction processes a single function and updates the ElsaGenFile structure.
// This function handles the complete processing of a function including parameter validation,
// result processing, generated function resolution, and variable name conflict resolution.
// It orchestrates all the necessary steps to prepare a function for code generation.
// Returns an error if any step in the processing fails.
func (g *Generator) processFunction(elsaGenFile *ElsaGenFile, fn FuncInfo) error {
	// Initialize function if not exists
	g.initializeFunction(elsaGenFile, fn)

	// Process parameters
	if err := g.processFunctionParams(elsaGenFile, fn); err != nil {
		return err
	}

	// Process results
	g.processFunctionResults(elsaGenFile, fn)

	// Process generated functions
	if err := g.processGeneratedFunctions(elsaGenFile, fn); err != nil {
		return err
	}

	// Resolve variable name conflicts
	g.resolveVariableNameConflicts(elsaGenFile, fn.FuncName)

	return nil
}

// initializeFunction initializes a function entry in the ElsaGenFile if it doesn't exist.
// This function ensures that each function has a proper entry in the Functions map.
// It creates the function structure with empty slices for parameters and results.
// The function also initializes the SourcePackages map for tracking variable sources.
// This is a no-op if the function already exists in the map.
func (g *Generator) initializeFunction(elsaGenFile *ElsaGenFile, fn FuncInfo) {
	if _, exists := elsaGenFile.Functions[fn.FuncName]; !exists {
		elsaGenFile.Functions[fn.FuncName] = ElsaGenFunction{
			SourcePackages: make(map[string]ElsaSourceDetail),
			Params:         make([]TypeInfo, 0),
			Results:        make([]TypeInfo, 0),
		}
	}
}

// processFunctionParams processes function parameters and validates for duplicates.
// This function extracts and processes all function parameters, checking for duplicate types.
// It creates type information for each parameter and sets up source package mappings.
// The function also handles import package registration for external dependencies.
// Returns an error if duplicate parameters are found or processing fails.
func (g *Generator) processFunctionParams(elsaGenFile *ElsaGenFile, fn FuncInfo) error {
	existingParams := make(map[string]bool)
	funcSetImportedPackages := g.createImportPackageSetter(elsaGenFile)

	for _, param := range fn.Params {
		// Check for duplicate parameters
		if existingParams[param.Type] {
			return fmt.Errorf("duplicate parameter on function %s: %s", fn.FuncName, param.Type)
		}
		existingParams[param.Type] = true

		// Process parameter type
		typeInfo := extractType(param.Type)
		typeInfo.ParamName = param.Name

		// Update function data
		funcData := elsaGenFile.Functions[fn.FuncName]
		funcData.Params = append(funcData.Params, typeInfo)
		elsaGenFile.Functions[fn.FuncName] = funcData

		// Set source package details
		key := fmt.Sprintf("%s.%s", typeInfo.Package, typeInfo.DataType)
		elsaGenFile.Functions[fn.FuncName].SourcePackages[key] = ElsaSourceDetail{
			VariableName: lowerFirst(param.Name),
			UsePointer:   typeInfo.UsePointer,
		}

		// Set imported packages
		funcSetImportedPackages(typeInfo)
	}

	return nil
}

// processFunctionResults processes function results and extracts struct data.
// This function processes all function return types and extracts struct field information.
// It updates the function data with result type information and populates struct data
// when the result is a struct type. This information is used for struct generation.
// The function does not return an error as it handles missing data gracefully.
func (g *Generator) processFunctionResults(elsaGenFile *ElsaGenFile, fn FuncInfo) {
	for _, result := range fn.Results {
		typeInfo := extractType(result.Type)

		// Update function data
		funcData := elsaGenFile.Functions[fn.FuncName]
		funcData.Results = append(funcData.Results, typeInfo)
		elsaGenFile.Functions[fn.FuncName] = funcData

		// Extract struct data if needed
		if result.IsStruct {
			if _, exists := elsaGenFile.StructsData[typeInfo.Package]; !exists {
				elsaGenFile.StructsData[typeInfo.Package] = result.StructFields
			}
		}
	}
}

// processGeneratedFunctions processes generated functions and resolves dependencies.
// This function handles the complex dependency resolution for generated functions.
// It processes functions in dependency order, ensuring all required parameters are available.
// The function continues processing until all generated functions are resolved or fails.
// Returns an error if dependency resolution fails or circular dependencies are detected.
func (g *Generator) processGeneratedFunctions(elsaGenFile *ElsaGenFile, fn FuncInfo) error {
	// Collect all generated functions
	var genFunctions []FuncInfo
	for _, gp := range fn.GenerateParams {
		genFunctions = append(genFunctions, elsaGenFile.Sets[gp]...)
	}

	funcSetImportedPackages := g.createImportPackageSetter(elsaGenFile)

	// Process functions until all dependencies are resolved
	for len(genFunctions) > 0 {
		processed := false

		for idx, gf := range genFunctions {
			// Check if all parameters are available
			if !g.areAllParametersAvailable(elsaGenFile, fn.FuncName, gf) {
				continue
			}

			// Process function results
			g.processGeneratedFunctionResults(elsaGenFile, fn.FuncName, gf, funcSetImportedPackages)

			// Add to generated functions
			elsaGenFile.FuncGenerated[fn.FuncName] = append(elsaGenFile.FuncGenerated[fn.FuncName], gf)

			// Remove from pending list
			genFunctions = removeArrayByIndex(genFunctions, idx)
			processed = true
			break
		}

		if !processed {
			return fmt.Errorf("failed get source from function %s", genFunctions[0].FuncName)
		}
	}

	return nil
}

// areAllParametersAvailable checks if all parameters for a generated function are available.
// This function validates that all required parameters for a generated function call
// have been resolved and are available in the source packages mapping.
// It checks each parameter type to ensure the corresponding variable name is set.
// Returns true if all parameters are available, false otherwise.
func (g *Generator) areAllParametersAvailable(elsaGenFile *ElsaGenFile, funcName string, gf FuncInfo) bool {
	for _, param := range gf.Params {
		typeInfo := extractType(param.Type)
		key := fmt.Sprintf("%s.%s", typeInfo.Package, typeInfo.DataType)
		if elsaGenFile.Functions[funcName].SourcePackages[key].VariableName == "" {
			return false
		}
	}
	return true
}

// processGeneratedFunctionResults processes results from generated functions.
// This function handles the results of generated function calls by creating source package
// mappings for the returned values. It extracts type information and sets up variable names.
// The function also registers import packages for the result types.
// This enables the results to be used as parameters for subsequent function calls.
func (g *Generator) processGeneratedFunctionResults(elsaGenFile *ElsaGenFile, funcName string, gf FuncInfo, funcSetImportedPackages func(TypeInfo)) {
	for _, result := range gf.Results {
		typeInfo := extractType(result.Type)
		key := fmt.Sprintf("%s.%s", typeInfo.Package, typeInfo.DataType)
		elsaGenFile.Functions[funcName].SourcePackages[key] = ElsaSourceDetail{
			VariableName: lowerFirst(typeInfo.DataType),
			UsePointer:   typeInfo.UsePointer,
		}
		funcSetImportedPackages(typeInfo)
	}
}

// resolveVariableNameConflicts resolves conflicts in variable names by adding numeric suffixes.
// This function ensures that all variable names within a function are unique by detecting
// duplicate variable names and appending numeric suffixes to make them unique.
// It processes all source packages for a function and updates conflicting names.
// This prevents compilation errors due to duplicate variable names.
func (g *Generator) resolveVariableNameConflicts(elsaGenFile *ElsaGenFile, funcName string) {
	variableNameCount := make(map[string]int)
	for key, source := range elsaGenFile.Functions[funcName].SourcePackages {
		variableNameCount[source.VariableName]++
		if variableNameCount[source.VariableName] > 1 {
			source.VariableName = fmt.Sprintf("%s%d", source.VariableName, variableNameCount[source.VariableName])
			elsaGenFile.Functions[funcName].SourcePackages[key] = source
		}
	}
}

// createImportPackageSetter creates a function to set imported packages with alias handling.
// This function returns a closure that manages import package registration with alias resolution.
// It handles duplicate package aliases by appending numeric suffixes when conflicts occur.
// The returned function can be used to register import packages with proper alias management.
// This ensures unique package aliases in the generated import section.
func (g *Generator) createImportPackageSetter(elsaGenFile *ElsaGenFile) func(TypeInfo) {
	counterAlias := make(map[string]int)
	// Default import packages "elsa"
	counterAlias["elsa"]++

	return func(typeInfo TypeInfo) {
		if _, exists := elsaGenFile.ImportedPackages[typeInfo.Package]; !exists {
			counterAlias[typeInfo.Alias]++
			useAlias := false
			if counterAlias[typeInfo.Alias] > 1 {
				typeInfo.Alias = fmt.Sprintf("%s%d", typeInfo.Alias, counterAlias[typeInfo.Alias])
				useAlias = true
			}
			elsaGenFile.ImportedPackages[typeInfo.Package] = ElsaImportedPackages{
				Alias:    typeInfo.Alias,
				UseAlias: useAlias,
			}
		}
	}
}

// validateGoCode validates the generated Go code for syntax correctness.
// This function uses the Go parser to check if the generated code has valid syntax.
// It also performs additional semantic checks to catch logical errors.
// This ensures that the generated code is syntactically and semantically correct before writing to file.
// Returns an error if the code contains syntax errors, semantic errors, or parsing fails.
func (g *Generator) validateGoCode(content string) error {
	fset := token.NewFileSet()
	_, err := parser.ParseFile(fset, "generated.go", content, parser.ParseComments)
	if err != nil {
		return fmt.Errorf("invalid Go syntax: %v", err)
	}

	// Additional semantic validation
	if err := g.validateSemanticErrors(content); err != nil {
		return fmt.Errorf("semantic error: %v", err)
	}

	return nil
}

// validateSemanticErrors performs additional semantic validation on the generated code.
// This function checks for common logical errors that the Go parser might not catch.
// It looks for patterns like bare type names in return statements or function calls.
// Returns an error if semantic issues are found.
func (g *Generator) validateSemanticErrors(content string) error {
	lines := strings.Split(content, "\n")

	for i, line := range lines {
		line = strings.TrimSpace(line)

		// Check for bare type names in return statements (including continuation lines)
		if strings.HasPrefix(line, "return ") || strings.HasPrefix(line, "}, ") {
			// Check for bare type names in return statements
			// Look for patterns like "return string", "return int", "return ..., string", "}, string"
			if strings.Contains(line, ", string") || strings.Contains(line, ", int") ||
				strings.Contains(line, ", bool") || strings.Contains(line, ", float") ||
				strings.HasSuffix(strings.TrimSpace(line), " string") ||
				strings.HasSuffix(strings.TrimSpace(line), " int") ||
				strings.HasSuffix(strings.TrimSpace(line), " bool") ||
				strings.HasSuffix(strings.TrimSpace(line), " float") {
				// Check if it's a string literal (contains quotes) - if so, it's valid
				if strings.Contains(line, `"`) {
					continue // Skip validation for string literals
				}
				return fmt.Errorf("line %d: bare type name in return statement: %s", i+1, line)
			}
		}

		// Check for bare type names in function calls (but not function signatures)
		if strings.Contains(line, "(") && strings.Contains(line, ")") {
			// Skip function signatures (lines starting with "func ")
			if strings.HasPrefix(line, "func ") {
				continue
			}
			// Look for patterns like "func(..., string)" or "func(..., int)" in function calls
			if strings.Contains(line, ", string)") || strings.Contains(line, ", int)") ||
				strings.Contains(line, ", bool)") || strings.Contains(line, ", float)") {
				return fmt.Errorf("line %d: bare type name in function call: %s", i+1, line)
			}
		}
	}

	return nil
}

// getDefaultValueForType returns the appropriate default value for a given type.
// This function handles built-in Go types and returns their zero values.
// For pointer types, it returns nil. For value types, it returns the appropriate zero value.
// Returns the default value as a string that can be used in Go code.
func (g *Generator) getDefaultValueForType(result TypeInfo) string {
	// Handle pointer types
	if result.UsePointer {
		return "nil"
	}

	// Handle built-in types
	switch result.DataType {
	case "string":
		return `""`
	case "int", "int8", "int16", "int32", "int64":
		return "0"
	case "uint", "uint8", "uint16", "uint32", "uint64":
		return "0"
	case "float32", "float64":
		return "0"
	case "bool":
		return "false"
	case "byte":
		return "0"
	case "rune":
		return "0"
	case "complex64", "complex128":
		return "0"
	case "error":
		return "nil"
	default:
		// For custom types, try to use the type name in lowercase
		// This is a fallback for unknown types
		return lowerFirst(result.DataType)
	}
}
