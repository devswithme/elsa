package generate

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"

	"go.risoftinc.com/elsa/constants"
)

type (
	ElsaGenFile struct {
		Target           string
		PackageName      string
		ImportedPackages map[string]ElsaImportedPackages
		StructsData      map[string][]StructFieldInfo
		Functions        map[string]ElsaGenFunction
		FuncGenerated    map[string][]FuncInfo
		Sets             map[string][]FuncInfo
		AliasCounter     map[string]int
	}

	ElsaImportedPackages struct {
		Alias    string
		UseAlias bool
	}

	ElsaGenFunction struct {
		SourcePackages map[string]ElsaSourceDetail
		Params         []TypeInfo
		Results        []TypeInfo
	}

	ElsaSourceDetail struct {
		VariableName string
		UsePointer   bool
	}
)

// processGenerateDependencies processes a single file for generation dependencies.
// This function is the main entry point for processing Go files that contain elsa.Generate calls.
// It extracts functions with elsa.Generate calls, analyzes elsa.Set declarations,
// and loads constructor information for the found functions.
// Returns an error if the processing fails at any step.
func (g *Generator) processGenerateDependencies(target string) error {
	// Initialize and validate dependencies
	elsaGenFile, err := g.initializeElsaGenFile(target)
	if err != nil {
		return err
	}

	// Generate the final file
	return g.GenerateElsaGenFile(target, *elsaGenFile)
}

// GenerateElsaGenFile generates an elsa_gen.go file for the target.
// This function creates the final generated file with all the processed content.
// It validates the generated Go code before writing to ensure syntax correctness.
// It writes the generated content to a file named elsa_gen.go in the same directory as the target.
// The package name is extracted from the target file and used in the generated file.
// Returns an error if validation fails or file writing fails.
func (g *Generator) GenerateElsaGenFile(target string, elsaGenFile ElsaGenFile) error {
	// Generate the content for elsa_gen.go
	content := g.generateElsaGenContent(elsaGenFile)

	// Validate the generated Go code
	if err := validateGoCode(content); err != nil {
		return fmt.Errorf("generated code validation failed: %v", err)
	}

	// Determine the output path (same directory as target)
	outputDir := filepath.Dir(target)
	outputPath := filepath.Join(outputDir, "elsa_gen.go")

	// Write the generated file
	err := os.WriteFile(outputPath, []byte(content), 0644)
	if err != nil {
		return fmt.Errorf("failed to write elsa_gen.go: %v", err)
	}

	fmt.Printf("%s Generated: %s from %s\n", constants.SuccessEmoji, outputPath, elsaGenFile.Target)
	return nil
}

// generateElsaGenHeader generates the standard header for elsa_gen.go files.
// This function creates the header section that includes build tags and generation directives.
// The header contains comments indicating the file is generated and should not be edited manually.
// It also includes go:generate and go:build directives for proper build integration.
func (g *Generator) generateElsaGenHeader() string {
	return `// Code generated by Elsa. DO NOT EDIT.

//go:generate go run -mod=mod go.risoftinc.com/elsa/cmd/elsa gen
//go:build !elsabuild
// +build !elsabuild

`
}

// generateElsaGenContent generates the complete content for elsa_gen.go file.
// This function orchestrates the generation of all file sections including header,
// package declaration, imports, structs, and functions.
// It combines all generated content into a single string that represents the complete file.
// The content includes generation timestamp and source file information.
func (g *Generator) generateElsaGenContent(elsaGenFile ElsaGenFile) string {
	var content string

	// Add header
	content += g.generateElsaGenHeader()

	// Add package declaration
	content += fmt.Sprintf("package %s\n\n", elsaGenFile.PackageName)

	// Add Import Selection
	content += g.generateElsaGenImportSelection(elsaGenFile)

	// Inject From
	content += fmt.Sprintf("// This file generated from %s at %s\n\n",
		getNameFile(elsaGenFile.Target), time.Now().Format(time.RFC3339),
	)

	// Add Structs
	content += g.generateElsaGenStructs(elsaGenFile)

	// Add Functions
	content += g.generateElsaGenFunctions(elsaGenFile)

	return content
}

// generateElsaGenImportSelection generates the import section for the generated file.
// This function creates the import block with all necessary package imports.
// It filters out built-in types and struct data packages to avoid unnecessary imports.
// The imports are sorted alphabetically for consistent ordering and readability.
// Returns the formatted import section as a string.
func (g *Generator) generateElsaGenImportSelection(elsaGenFile ElsaGenFile) string {
	content := "import (\n\t\"go.risoftinc.com/elsa\"\n\n"

	// Convert map to slice for consistent ordering
	var packages []string
	for pkg := range elsaGenFile.ImportedPackages {
		if pkg == "" || isBuiltinType(pkg) {
			continue
		}
		if _, ok := elsaGenFile.StructsData[pkg]; ok {
			continue
		}
		importedPackage := elsaGenFile.ImportedPackages[pkg]
		packages = append(packages, fmt.Sprintf("\t%s \"%s\"\n", importedPackage.Alias, pkg))
	}

	// Sort packages alphabetically for consistent order
	sort.Strings(packages)

	// Generate imports in sorted order
	for _, pkg := range packages {
		content += pkg
	}

	return content + ")\n\n"
}

// generateElsaGenStructs generates struct definitions for the generated file.
// This function creates Go struct type definitions based on the struct data collected.
// It handles proper field alignment by calculating the maximum field name length.
// Each struct field is formatted with appropriate padding for clean code generation.
// Returns the formatted struct definitions as a string.
func (g *Generator) generateElsaGenStructs(elsaGenFile ElsaGenFile) string {
	content := ""
	for pkg, structs := range elsaGenFile.StructsData {
		content += fmt.Sprintf("type %s struct {\n", pkg)

		// Find the maximum field name length for alignment
		maxNameLength := 0
		for _, structData := range structs {
			if len(structData.Name) > maxNameLength {
				maxNameLength = len(structData.Name)
			}
		}

		// Generate struct fields with proper alignment
		for _, structData := range structs {
			et := extractTypeWithImports(structData.Type, g.imports)

			var typeName string
			if et.Package == "" {
				// Builtin type, use DataType directly
				typeName = et.DataType
			} else {
				// Custom type, use alias + DataType
				if importedPkg, exists := elsaGenFile.ImportedPackages[et.Package]; exists && importedPkg.Alias != "" {
					typeName = importedPkg.Alias + "." + et.DataType
				} else {
					// Fallback to DataType only if no alias found
					typeName = et.DataType
				}
			}

			// Create padding spaces for alignment
			padding := strings.Repeat(" ", maxNameLength-len(structData.Name))
			content += fmt.Sprintf("\t%s%s %s\n", structData.Name, padding, typeName)
		}
		content += "}\n\n"
	}
	return content
}

// generateElsaGenFunctions generates all function definitions for the generated file.
// This function iterates through all functions in the ElsaGenFile and generates
// their complete definitions including parameters, return types, and function bodies.
// It delegates the actual function generation to generateSingleFunction for each function.
// Returns the concatenated function definitions as a string.
func (g *Generator) generateElsaGenFunctions(elsaGenFile ElsaGenFile) string {
	content := ""
	for name, function := range elsaGenFile.Functions {
		content += g.generateSingleFunction(name, function, elsaGenFile)
	}
	return content
}

// generateSingleFunction generates a complete function definition with all its components.
// This function creates a single function with its signature (parameters and return types)
// and complete function body including generated function calls and return statements.
// It orchestrates the generation of function parameters, results, and body content.
// Returns the complete function definition as a formatted string.
func (g *Generator) generateSingleFunction(name string, function ElsaGenFunction, elsaGenFile ElsaGenFile) string {
	// Generate function signature
	params := g.generateFunctionParams(function, elsaGenFile)
	results := g.generateFunctionResults(function)
	returnStr := g.formatReturnTypes(results)

	content := fmt.Sprintf("func %s(%s) %s {\n", name, strings.Join(params, ", "), returnStr)

	// Generate function body
	content += g.generateFunctionBody(name, function, elsaGenFile)
	content += "}\n\n"

	return content
}

// generateFunctionParams generates the parameter list for a function signature.
// This function processes all function parameters and formats them with proper types.
// It handles pointer types, imported packages, and built-in types appropriately.
// The parameters are formatted as "variableName type" pairs for the function signature.
// Returns a slice of formatted parameter strings.
func (g *Generator) generateFunctionParams(function ElsaGenFunction, elsaGenFile ElsaGenFile) []string {
	var params []string
	for _, param := range function.Params {
		var typeName string
		var variableName string

		if param.Package == "" {
			// Builtin type
			typeName = param.DataType
			if param.UsePointer {
				typeName = "*" + typeName
			}
			// For builtin types, use the parameter name directly
			variableName = param.ParamName
		} else {
			// Custom type
			importedPackage := elsaGenFile.ImportedPackages[param.Package].Alias
			if param.UsePointer {
				importedPackage = "*" + importedPackage
			}
			if _, ok := elsaGenFile.StructsData[param.Package]; !ok {
				importedPackage += "." + param.DataType
			}
			typeName = importedPackage

			// Get variable name from SourcePackages
			key := param.Package + "." + param.DataType
			variableName = function.SourcePackages[key].VariableName
		}

		paramStr := fmt.Sprintf("%s %s", variableName, typeName)
		params = append(params, paramStr)
	}
	return params
}

// generateFunctionResults generates the return type list for a function signature.
// This function processes all function return types and formats them appropriately.
// It handles pointer types by adding the asterisk (*) prefix when needed.
// The return types are formatted as type names for the function signature.
// Returns a slice of formatted return type strings.
func (g *Generator) generateFunctionResults(function ElsaGenFunction) []string {
	var results []string
	for _, result := range function.Results {
		resultType := result.Package
		if result.UsePointer {
			resultType = "*" + resultType
		}
		results = append(results, resultType)
	}
	return results
}

// formatReturnTypes formats the return type string for function signatures.
// This function handles single and multiple return types appropriately.
// For single return type, it returns the type as-is.
// For multiple return types, it wraps them in parentheses for proper Go syntax.
// Returns the formatted return type string.
func (g *Generator) formatReturnTypes(results []string) string {
	returnStr := strings.Join(results, ", ")
	if len(results) > 1 {
		returnStr = "(" + returnStr + ")"
	}
	return returnStr
}

// generateFunctionBody generates the complete function body with all necessary components.
// This function creates the function body including calls to generated functions,
// elsa.Generate call, and return statement with proper struct initialization.
// It processes all generated functions and collects their return variables.
// Returns the complete function body as a formatted string.
func (g *Generator) generateFunctionBody(name string, function ElsaGenFunction, elsaGenFile ElsaGenFile) string {
	var content string
	var elsaGeneratedVariables []string

	// Generate calls to generated functions
	for _, generated := range elsaGenFile.FuncGenerated[name] {
		callContent, variables := g.generateFunctionCall(generated, function, elsaGenFile)
		content += callContent
		elsaGeneratedVariables = append(elsaGeneratedVariables, variables...)
	}

	// Add elsa.Generate call
	content += fmt.Sprintf("\n\telsa.Generate(%s)\n", strings.Join(elsaGeneratedVariables, ", "))

	// Generate return statement
	content += g.generateReturnStatement(function, elsaGenFile)

	return content
}

// generateFunctionCall generates a function call statement for a generated function.
// This function creates the complete function call including parameter formatting
// and return variable assignment. It handles pointer dereferencing and referencing
// based on the parameter and source types. Returns the call statement and result variables.
// Returns the formatted function call string and a slice of result variable names.
func (g *Generator) generateFunctionCall(generated FuncInfo, function ElsaGenFunction, elsaGenFile ElsaGenFile) (string, []string) {
	importedPackage := elsaGenFile.ImportedPackages[generated.PkgPath].Alias
	var params, results []string

	// Generate parameters
	for _, param := range generated.Params {
		et := extractTypeWithImports(param.Type, g.imports)
		source := function.SourcePackages[et.Package+"."+et.DataType]
		paramValue := g.formatParameterValue(source, et)
		params = append(params, paramValue)
	}

	// Generate results
	for _, result := range generated.Results {
		et := extractTypeWithImports(result.Type, g.imports)
		resultVar := function.SourcePackages[et.Package+"."+et.DataType].VariableName
		results = append(results, resultVar)
	}

	callContent := fmt.Sprintf("\t%s := %s.%s(%s)\n",
		strings.Join(results, ", "),
		importedPackage,
		generated.FuncName,
		strings.Join(params, ", "))

	return callContent, results
}

// formatParameterValue formats a parameter value based on pointer type requirements.
// This function handles the conversion between pointer and value types when passing parameters.
// It adds dereference (*) or reference (&) operators as needed to match type requirements.
// The formatting ensures type compatibility between source and target parameter types.
// Returns the properly formatted parameter value string.
func (g *Generator) formatParameterValue(source ElsaSourceDetail, et TypeInfo) string {
	if source.UsePointer == et.UsePointer {
		return source.VariableName
	} else if et.UsePointer && !source.UsePointer {
		return "*" + source.VariableName
	} else {
		return "&" + source.VariableName
	}
}

// generateReturnStatement generates the return statement for a function.
// This function creates the return statement with proper struct initialization if needed.
// It handles pointer types by adding the reference operator (&) when required.
// For struct types, it generates struct literal initialization with field assignments.
// Returns the formatted return statement string.
func (g *Generator) generateReturnStatement(function ElsaGenFunction, elsaGenFile ElsaGenFile) string {
	content := "\treturn "
	for idx, result := range function.Results {
		if idx > 0 {
			content += ", "
		}
		// Generate struct content if needed
		structContent := g.generateStructContent(result, function, elsaGenFile)

		// Generate return value based on type
		if structContent != "" {
			// For struct types with field assignments, use struct literal
			if result.UsePointer {
				content += "&" + result.Package + structContent
			} else {
				content += result.Package + structContent
			}
		} else {
			// Check if this is a struct type
			if _, isStruct := elsaGenFile.StructsData[result.Package]; isStruct {
				// For struct types without field assignments, use empty struct literal
				if result.UsePointer {
					content += "&" + result.Package + "{}"
				} else {
					content += result.Package + "{}"
				}
			} else {
				// For non-struct types, we need to return a variable name or default value
				// Find the variable name from source packages
				key := fmt.Sprintf("%s.%s", result.Package, result.DataType)
				if source, exists := function.SourcePackages[key]; exists {
					content += source.VariableName
				} else {
					// Fallback: return default value based on type
					content += getDefaultValueForType(result)
				}
			}
		}
	}
	content += "\n"
	return content
}

// generateStructContent generates struct literal initialization content.
// This function creates the struct initialization block with field assignments.
// It maps struct fields to their corresponding source variables from the function.
// The struct literal is formatted with proper indentation and field assignments.
// Returns the formatted struct initialization string, empty if not a struct type.
func (g *Generator) generateStructContent(result TypeInfo, function ElsaGenFunction, elsaGenFile ElsaGenFile) string {
	structContent := ""
	if structFields, exists := elsaGenFile.StructsData[result.Package]; exists {
		// First pass: collect all assignments and find max field name length
		var assignments []struct {
			fieldName string
			value     string
		}
		maxFieldNameLength := 0

		for _, structData := range structFields {
			// Check if this is a builtin type
			et := extractTypeWithImports(structData.Type, g.imports)
			var variableName string
			var found bool

			if et.Package == "" {
				// Builtin type, look for matching parameter in function
				key := fmt.Sprintf("%s.%s", et.Package, et.DataType) // This will be ".string"
				if source, exists := function.SourcePackages[key]; exists {
					variableName = source.VariableName
					found = true
					if source.UsePointer {
						variableName = "*" + source.VariableName
					}
				}
			} else {
				// Custom type, look up in SourcePackages
				key := fmt.Sprintf("%s.%s", et.Package, et.DataType)
				if source, exists := function.SourcePackages[key]; exists {
					variableName = source.VariableName
					found = true
					if source.UsePointer {
						variableName = "*" + source.VariableName
					}
				}
			}

			// Only add assignment if we found a matching variable
			if found {
				assignments = append(assignments, struct {
					fieldName string
					value     string
				}{structData.Name, variableName})

				if len(structData.Name) > maxFieldNameLength {
					maxFieldNameLength = len(structData.Name)
				}
			}
		}

		// Second pass: generate aligned assignments
		for _, assignment := range assignments {
			padding := strings.Repeat(" ", maxFieldNameLength-len(assignment.fieldName))
			structContent += fmt.Sprintf("\t\t%s:%s %s,\n",
				assignment.fieldName,
				padding,
				assignment.value)
		}

		if structContent != "" {
			structContent = "{\n" + structContent + "\t}"
		}
	}
	return structContent
}

// initializeElsaGenFile initializes the ElsaGenFile structure with basic data.
// This function sets up the main data structure for code generation by extracting
// functions with elsa.Generate calls and parsing elsa.Set declarations.
// It validates that at least one function with elsa.Generate is found.
// Returns a pointer to the initialized ElsaGenFile or an error if initialization fails.
func (g *Generator) initializeElsaGenFile(target string) (*ElsaGenFile, error) {
	goModDir, err := g.FindGoModDir(target)
	if err != nil {
		return nil, err
	}

	// Extract functions containing elsa.Generate
	funcs, err := g.ExtractElsaGenerateFuncs(target)
	if err != nil {
		return nil, err
	}

	if len(funcs) == 0 {
		return nil, fmt.Errorf("no functions with elsa.Generate calls found")
	}

	sets, err := g.ParseElsaSets(goModDir, target)
	if err != nil {
		return nil, err
	}

	elsaGenFile := &ElsaGenFile{
		Target:           target,
		PackageName:      funcs[0].PkgName,
		ImportedPackages: make(map[string]ElsaImportedPackages),
		StructsData:      make(map[string][]StructFieldInfo),
		Functions:        make(map[string]ElsaGenFunction),
		FuncGenerated:    make(map[string][]FuncInfo),
		Sets:             sets,
		AliasCounter:     make(map[string]int),
	}

	// Process each function
	for _, fn := range funcs {
		if err := g.processFunction(elsaGenFile, fn); err != nil {
			return nil, err
		}
	}

	return elsaGenFile, nil
}

// processFunction processes a single function and updates the ElsaGenFile structure.
// This function handles the complete processing of a function including parameter validation,
// result processing, generated function resolution, and variable name conflict resolution.
// It orchestrates all the necessary steps to prepare a function for code generation.
// Returns an error if any step in the processing fails.
func (g *Generator) processFunction(elsaGenFile *ElsaGenFile, fn FuncInfo) error {
	// Initialize function if not exists
	g.initializeFunction(elsaGenFile, fn)

	// Process parameters
	if err := g.processFunctionParams(elsaGenFile, fn); err != nil {
		return err
	}

	// Process results
	g.processFunctionResults(elsaGenFile, fn)

	// Process generated functions
	if err := g.processGeneratedFunctions(elsaGenFile, fn); err != nil {
		return err
	}

	// Resolve variable name conflicts
	g.resolveVariableNameConflicts(elsaGenFile, fn.FuncName)

	return nil
}

// initializeFunction initializes a function entry in the ElsaGenFile if it doesn't exist.
// This function ensures that each function has a proper entry in the Functions map.
// It creates the function structure with empty slices for parameters and results.
// The function also initializes the SourcePackages map for tracking variable sources.
// This is a no-op if the function already exists in the map.
func (g *Generator) initializeFunction(elsaGenFile *ElsaGenFile, fn FuncInfo) {
	if _, exists := elsaGenFile.Functions[fn.FuncName]; !exists {
		elsaGenFile.Functions[fn.FuncName] = ElsaGenFunction{
			SourcePackages: make(map[string]ElsaSourceDetail),
			Params:         make([]TypeInfo, 0),
			Results:        make([]TypeInfo, 0),
		}
	}
}

// processFunctionParams processes function parameters and validates for duplicates.
// This function extracts and processes all function parameters, checking for duplicate types.
// It creates type information for each parameter and sets up source package mappings.
// The function also handles import package registration for external dependencies.
// Returns an error if duplicate parameters are found or processing fails.
func (g *Generator) processFunctionParams(elsaGenFile *ElsaGenFile, fn FuncInfo) error {
	existingParams := make(map[string]bool)
	funcSetImportedPackages := g.createImportPackageSetter(elsaGenFile)

	for _, param := range fn.Params {
		// Check for duplicate parameters
		if existingParams[param.Type] {
			return fmt.Errorf("duplicate parameter on function %s: %s", fn.FuncName, param.Type)
		}
		existingParams[param.Type] = true

		// Process parameter type
		typeInfo := extractTypeWithImports(param.Type, g.imports)
		typeInfo.ParamName = param.Name

		// Update function data
		funcData := elsaGenFile.Functions[fn.FuncName]
		funcData.Params = append(funcData.Params, typeInfo)
		elsaGenFile.Functions[fn.FuncName] = funcData

		// Set source package details
		key := fmt.Sprintf("%s.%s", typeInfo.Package, typeInfo.DataType)
		elsaGenFile.Functions[fn.FuncName].SourcePackages[key] = ElsaSourceDetail{
			VariableName: lowerFirst(param.Name),
			UsePointer:   typeInfo.UsePointer,
		}

		// Set imported packages
		funcSetImportedPackages(typeInfo)
	}

	return nil
}

// processFunctionResults processes function results and extracts struct data.
// This function processes all function return types and extracts struct field information.
// It updates the function data with result type information and populates struct data
// when the result is a struct type. This information is used for struct generation.
// The function does not return an error as it handles missing data gracefully.
func (g *Generator) processFunctionResults(elsaGenFile *ElsaGenFile, fn FuncInfo) {
	funcSetImportedPackages := g.createImportPackageSetter(elsaGenFile)

	for _, result := range fn.Results {
		typeInfo := extractTypeWithImports(result.Type, g.imports)

		// Update function data
		funcData := elsaGenFile.Functions[fn.FuncName]
		funcData.Results = append(funcData.Results, typeInfo)
		elsaGenFile.Functions[fn.FuncName] = funcData

		// Set imported packages for result type
		funcSetImportedPackages(typeInfo)

		// Extract struct data if needed
		if result.IsStruct {
			if _, exists := elsaGenFile.StructsData[typeInfo.Package]; !exists {
				elsaGenFile.StructsData[typeInfo.Package] = result.StructFields

				// Register import packages for struct fields
				for _, structField := range result.StructFields {
					fieldTypeInfo := extractTypeWithImports(structField.Type, g.imports)
					funcSetImportedPackages(fieldTypeInfo)
				}
			}
		}
	}
}

// processGeneratedFunctions processes generated functions and resolves dependencies.
// This function handles the complex dependency resolution for generated functions.
// It processes functions in dependency order, ensuring all required parameters are available.
// The function continues processing until all generated functions are resolved or fails.
// Returns an error if dependency resolution fails or circular dependencies are detected.
func (g *Generator) processGeneratedFunctions(elsaGenFile *ElsaGenFile, fn FuncInfo) error {
	// Collect all generated functions
	var genFunctions []FuncInfo
	for _, gp := range fn.GenerateParams {
		genFunctions = append(genFunctions, elsaGenFile.Sets[gp]...)
	}

	funcSetImportedPackages := g.createImportPackageSetter(elsaGenFile)

	// Process functions until all dependencies are resolved
	for len(genFunctions) > 0 {
		processed := false

		for idx, gf := range genFunctions {
			// Check if all parameters are available
			if !g.areAllParametersAvailable(elsaGenFile, fn.FuncName, gf) {
				continue
			}

			// Process function results
			g.processGeneratedFunctionResults(elsaGenFile, fn.FuncName, gf, funcSetImportedPackages)

			// Add to generated functions
			elsaGenFile.FuncGenerated[fn.FuncName] = append(elsaGenFile.FuncGenerated[fn.FuncName], gf)

			// Remove from pending list
			genFunctions = removeArrayByIndex(genFunctions, idx)
			processed = true
			break
		}

		if !processed {
			return fmt.Errorf("failed get source from function %s", genFunctions[0].FuncName)
		}
	}

	return nil
}

// areAllParametersAvailable checks if all parameters for a generated function are available.
// This function validates that all required parameters for a generated function call
// have been resolved and are available in the source packages mapping.
// It checks each parameter type to ensure the corresponding variable name is set.
// Returns true if all parameters are available, false otherwise.
func (g *Generator) areAllParametersAvailable(elsaGenFile *ElsaGenFile, funcName string, gf FuncInfo) bool {
	for _, param := range gf.Params {
		typeInfo := extractTypeWithImports(param.Type, g.imports)
		key := fmt.Sprintf("%s.%s", typeInfo.Package, typeInfo.DataType)
		if elsaGenFile.Functions[funcName].SourcePackages[key].VariableName == "" {
			return false
		}
	}
	return true
}

// processGeneratedFunctionResults processes results from generated functions.
// This function handles the results of generated function calls by creating source package
// mappings for the returned values. It extracts type information and sets up variable names.
// The function also registers import packages for the result types.
// This enables the results to be used as parameters for subsequent function calls.
func (g *Generator) processGeneratedFunctionResults(elsaGenFile *ElsaGenFile, funcName string, gf FuncInfo, funcSetImportedPackages func(TypeInfo)) {
	for _, result := range gf.Results {
		typeInfo := extractTypeWithImports(result.Type, g.imports)
		key := fmt.Sprintf("%s.%s", typeInfo.Package, typeInfo.DataType)
		elsaGenFile.Functions[funcName].SourcePackages[key] = ElsaSourceDetail{
			VariableName: lowerFirst(typeInfo.DataType),
			UsePointer:   typeInfo.UsePointer,
		}
		funcSetImportedPackages(typeInfo)
	}
}

// resolveVariableNameConflicts resolves conflicts in variable names by adding numeric suffixes.
// This function ensures that all variable names within a function are unique by detecting
// duplicate variable names and appending numeric suffixes to make them unique.
// It processes all source packages for a function and updates conflicting names.
// This prevents compilation errors due to duplicate variable names.
func (g *Generator) resolveVariableNameConflicts(elsaGenFile *ElsaGenFile, funcName string) {
	variableNameCount := make(map[string]int)
	for key, source := range elsaGenFile.Functions[funcName].SourcePackages {
		variableNameCount[source.VariableName]++
		if variableNameCount[source.VariableName] > 1 {
			source.VariableName = fmt.Sprintf("%s%d", source.VariableName, variableNameCount[source.VariableName])
			elsaGenFile.Functions[funcName].SourcePackages[key] = source
		}
	}
}

// createImportPackageSetter creates a function to set imported packages with alias handling.
// This function returns a closure that manages import package registration with alias resolution.
// It handles duplicate package aliases by appending numeric suffixes when conflicts occur.
// The returned function can be used to register import packages with proper alias management.
// This ensures unique package aliases in the generated import section.
func (g *Generator) createImportPackageSetter(elsaGenFile *ElsaGenFile) func(TypeInfo) {
	// Initialize default import packages "elsa"
	if elsaGenFile.AliasCounter["elsa"] == 0 {
		elsaGenFile.AliasCounter["elsa"]++
	}

	return func(typeInfo TypeInfo) {
		if _, exists := elsaGenFile.ImportedPackages[typeInfo.Package]; !exists {
			elsaGenFile.AliasCounter[typeInfo.Alias]++
			useAlias := false
			if elsaGenFile.AliasCounter[typeInfo.Alias] > 1 {
				typeInfo.Alias = fmt.Sprintf("%s%d", typeInfo.Alias, elsaGenFile.AliasCounter[typeInfo.Alias])
				useAlias = true
			}
			elsaGenFile.ImportedPackages[typeInfo.Package] = ElsaImportedPackages{
				Alias:    typeInfo.Alias,
				UseAlias: useAlias,
			}
		}
	}
}
