# Elsa Generate & Dependency Injection Guide

## Overview

Elsa's `generate` command (alias: `gen`) provides a powerful dependency injection system for Go applications. This feature automatically generates dependency injection code based on your function definitions and dependency relationships, eliminating the need for manual dependency wiring.

## Background: Why Dependency Injection?

Dependency injection is a design pattern that helps manage dependencies between different components in your application. In traditional Go applications, you often need to manually wire dependencies like this:

```go
// Manual dependency wiring - tedious and error-prone
func main() {
    db := connectDatabase()
    userRepo := NewUserRepository(db)
    userService := NewUserService(userRepo)
    userHandler := NewUserHandler(userService)
    
    // More dependencies...
    logger := NewLogger()
    cache := NewCache()
    // ... and so on
}
```

**Problems with manual wiring:**
- **Error-prone**: Easy to forget dependencies or wire them incorrectly
- **Maintenance burden**: Adding new dependencies requires updating multiple places
- **Testing complexity**: Hard to mock dependencies for unit tests
- **Code duplication**: Similar wiring patterns repeated across different functions

**Benefits of Elsa's dependency injection:**
- **Automatic resolution**: Dependencies are resolved automatically based on function signatures
- **Type safety**: Compile-time checking ensures all dependencies are properly typed
- **Easy testing**: Generated code makes it easy to inject mocks for testing
- **Clean separation**: Business logic separated from dependency wiring
- **Consistent patterns**: Standardized approach across your entire application

## How It Works

### 1. Build Tags System

Elsa uses Go's build tag system to separate dependency definition from generated code:

- **`//go:build elsabuild`**: Files containing dependency definitions (not included in normal builds)
- **`//go:build !elsabuild`**: Generated files (included in normal builds, excluded during generation)

### 2. Dependency Definition Files

Create files with `elsabuild` tags to define your dependencies:

```go
//go:build elsabuild
// +build elsabuild

package http

import (
    "go.risoftinc.com/elsa"
    "gorm.io/gorm"
)

type Dependencies struct {
    UserHandler UserHandler
}

func InitializeHandler(db *gorm.DB) *Dependencies {
    elsa.Generate(
        RepositorySet,
        ServicesSet,
        HandlerSet,
    )
    return nil
}

var RepositorySet = elsa.Set(
    NewUserRepository,
)

var ServicesSet = elsa.Set(
    NewUserService,
)

var HandlerSet = elsa.Set(
    NewUserHandler,
)
```

### 3. Generated Code

Running `elsa generate` creates `elsa_gen.go` with the actual dependency injection logic:

```go
// Code generated by Elsa. DO NOT EDIT.

//go:generate go run -mod=mod go.risoftinc.com/elsa/cmd/elsa gen
//go:build !elsabuild
// +build !elsabuild

package http

func InitializeHandler(db *gorm.DB) *Dependencies {
    userRepo := NewUserRepository(db)
    userSvc := NewUserService(userRepo)
    userHandler := NewUserHandler(userSvc)

    elsa.Generate(userRepo, userSvc, userHandler)
    return &Dependencies{
        UserHandler: userHandler,
    }
}
```

## Command Usage

### Basic Commands

```bash
# Generate dependency injection code
elsa generate

# Short alias
elsa gen

# Generate for specific directory
elsa generate ./infrastructure/http

# Generate for specific directory (alias)
elsa gen ./infrastructure/http
```

### Command Options

| Option | Description |
|--------|-------------|
| `[directory]` | Target directory to search for `elsabuild` files (default: current directory) |

## File Structure Requirements

### 1. Build Tag Requirements

**Source files** (dependency definition):
- Must have `//go:build elsabuild` tag
- Must have `// +build elsabuild` tag (for Go < 1.17 compatibility)
- Contains dependency definitions and `elsa.Generate()` calls

**Generated files**:
- Automatically created as `elsa_gen.go`
- Has `//go:build !elsabuild` tag
- Contains actual dependency injection implementation

### 2. Function Requirements

#### Initialize Function
- **Must contain `elsa.Generate()` call**: Only functions with this call will be processed
- **Parameter uniqueness**: All parameters must have different types (no duplicates)
- **Return type**: Must return the data you want to publish/expose (can be struct, string, interface, slice, primitive types, etc. **Map not supported**)
- **Return type uniqueness**: Return type must be different from all parameters and no duplicate types in return (both single and multiple returns)

```go
func InitializeHandler(db *gorm.DB) *Dependencies {
    elsa.Generate(
        RepositorySet,
        ServicesSet,
        HandlerSet,
    )
    return nil // This will be replaced with actual implementation
}
```

#### Dependency Sets
- **Variable naming**: Use descriptive names ending with "Set" (e.g., `RepositorySet`, `ServiceSet`)
- **Layer separation**: Group dependencies by architectural layer for better organization
- **Function references**: List constructor functions that build your dependencies

```go
var RepositorySet = elsa.Set(
    NewUserRepository,
    NewOrderRepository,
)

var ServiceSet = elsa.Set(
    NewUserService,
    NewOrderService,
)
```

#### Constructor Functions
- **Parameter availability**: All required parameters must be available from:
  - Initialize function parameters
  - Other generated constructor functions
- **Dependency chain**: Dependencies are resolved automatically based on parameter types

## Advanced Examples

### Various Valid Return Types

```go
//go:build elsabuild
// +build elsabuild

package examples

import (
    "go.risoftinc.com/elsa"
    "gorm.io/gorm"
)

// 1. Return struct (most common)
type Dependencies struct {
    UserHandler UserHandler
}

func InitializeWithStruct(db *gorm.DB) *Dependencies {
    elsa.Generate(HandlerSet)
    return nil
}

// 2. Return string
func InitializeConfig() string {
    elsa.Generate(ConfigSet)
    return ""
}

// 3. Return interface
func InitializeService() UserServiceInterface {
    elsa.Generate(ServiceSet)
    return nil
}

// 4. Return slice
func InitializeHandlers() []Handler {
    elsa.Generate(HandlerSet)
    return nil
}

// 5. Return primitive type
func InitializePort() int {
    elsa.Generate(ConfigSet)
    return 0
}

var HandlerSet = elsa.Set(NewUserHandler)
var ConfigSet = elsa.Set(NewConfig)
var ServiceSet = elsa.Set(NewUserService)
```

### Complex Dependency Chain

```go
//go:build elsabuild
// +build elsabuild

package infrastructure

import (
    "go.risoftinc.com/elsa"
    "gorm.io/gorm"
    "go.risoftinc.com/gologger"
    "go.risoftinc.com/goresponse"
)

type Dependencies struct {
    UserHandler    UserHandler
    OrderHandler   OrderHandler
    Middleware     Middleware
}

func InitializeServices(
    db *gorm.DB,
    logger gologger.Logger,
    async *goresponse.AsyncConfigManager,
) *Dependencies {
    elsa.Generate(
        RepositorySet,
        ServiceSet,
        HandlerSet,
        MiddlewareSet,
    )
    return nil
}

// Repositories
var RepositorySet = elsa.Set(
    NewUserRepository,
    NewOrderRepository,
    NewProductRepository,
)

// Services
var ServiceSet = elsa.Set(
    NewUserService,
    NewOrderService,
    NewProductService,
    NewEmailService,
)

// Handlers
var HandlerSet = elsa.Set(
    NewUserHandler,
    NewOrderHandler,
    NewProductHandler,
)

// Middleware
var MiddlewareSet = elsa.Set(
    NewAuthMiddleware,
    NewLoggingMiddleware,
)
```

### Generated Output

```go
// Code generated by Elsa. DO NOT EDIT.

//go:generate go run -mod=mod go.risoftinc.com/elsa/cmd/elsa gen
//go:build !elsabuild
// +build !elsabuild

package infrastructure

import (
    "go.risoftinc.com/elsa"
    
    gologger "go.risoftinc.com/gologger"
    goresponse "go.risoftinc.com/goresponse"
    gorm "gorm.io/gorm"
)

func InitializeServices(db *gorm.DB, logger gologger.Logger, async *goresponse.AsyncConfigManager) *Dependencies {
    userRepository := NewUserRepository(db)
    orderRepository := NewOrderRepository(db)
    productRepository := NewProductRepository(db)
    
    userService := NewUserService(logger, userRepository)
    orderService := NewOrderService(logger, orderRepository, userService)
    productService := NewProductService(logger, productRepository)
    emailService := NewEmailService(logger)
    
    authMiddleware := NewAuthMiddleware(logger)
    loggingMiddleware := NewLoggingMiddleware(logger)
    
    userHandler := NewUserHandler(logger, userService, authMiddleware)
    orderHandler := NewOrderHandler(logger, orderService, authMiddleware)
    productHandler := NewProductHandler(logger, productService)
    
    elsa.Generate(userRepository, orderRepository, productRepository, userService, orderService, productService, emailService, authMiddleware, loggingMiddleware, userHandler, orderHandler, productHandler)
    
    return &Dependencies{
        UserHandler:  userHandler,
        OrderHandler: orderHandler,
        Middleware:   authMiddleware,
    }
}
```

## Best Practices

### 1. Layer Organization
Group your dependency sets by architectural layers:

```go
// Data layer
var RepositorySet = elsa.Set(
    NewUserRepository,
    NewOrderRepository,
)

// Business logic layer
var ServiceSet = elsa.Set(
    NewUserService,
    NewOrderService,
)

// Presentation layer
var HandlerSet = elsa.Set(
    NewUserHandler,
    NewOrderHandler,
)
```

### 2. Parameter Naming and Type Aliases
Use descriptive parameter names and type aliases for same types:

```go
// Create type aliases for same types
type UserDB = gorm.DB
type OrderDB = gorm.DB
type MainLogger = gologger.Logger
type ErrorLogger = gologger.Logger

func InitializeServices(
    userDB *UserDB,        // Database for users
    orderDB *OrderDB,      // Database for orders
    mainLogger MainLogger, // Main logger
    errorLogger ErrorLogger, // Error logger
    config Config,         // Application configuration
) *Dependencies {
    // ...
}
```

### 3. Return Type Design
Design your return struct to expose only what consumers need:

```go
type Dependencies struct {
    // Public API - what consumers need
    UserHandler UserHandler
    OrderHandler OrderHandler
    
    // Internal dependencies - not exposed
    // (these are still available via elsa.Generate)
}
```

### 4. Error Handling
Handle errors in your constructor functions, not in the generated code:

```go
func NewUserService(logger gologger.Logger, repo UserRepository) UserService {
    if logger == nil {
        panic("logger is required")
    }
    if repo == nil {
        panic("user repository is required")
    }
    return &userService{logger: logger, repo: repo}
}
```

## Troubleshooting

### Common Issues

#### 1. "duplicate parameter" Error
**Problem**: Multiple parameters with the same type
```go
func InitializeServices(db1 *gorm.DB, db2 *gorm.DB) *Dependencies // ❌ Error
```

**Solution**: Use type aliases to differentiate same types
```go
// Create type aliases to differentiate database connections
type MysqlCon = gorm.DB
type PostgresCon = gorm.DB

// Or with more descriptive aliases
type UserDB = gorm.DB
type OrderDB = gorm.DB

// Now you can use different types
func InitializeServices(db1 *MysqlCon, db2 *PostgresCon) *Dependencies // ✅ Correct
func InitializeServices(userDB *UserDB, orderDB *OrderDB) *Dependencies // ✅ Correct
```

**How to create type aliases:**
```go
// Syntax: type AliasName = OriginalType
type DatabaseConnection = gorm.DB
type LoggerInstance = gologger.Logger
type ConfigData = Config
```

#### 1.1. "duplicate return type" Error
**Problem**: Return type same as one of the parameters or multiple returns with same type
```go
func InitializeServices(db *gorm.DB) (*gorm.DB, *gorm.DB) // ❌ Error - multiple returns with same type
```

**Solution**: Use return type different from all parameters and no duplicate types in return
```go
func InitializeServices(db *gorm.DB) (*Dependencies, string) // ✅ Correct - return types different
```

#### 1.2. "return type not defined" Error
**Problem**: Return type not defined in generated functions or parameters
```go
func InitializeServices(db *gorm.DB) SomeUndefinedType // ❌ Error - type not defined
```

**Solution**: Ensure return type is defined in dependency sets or parameters
```go
// Ensure SomeType exists in dependency sets
var ServiceSet = elsa.Set(NewSomeService) // NewSomeService must return SomeType
```

#### 1.3. "map type not supported" Error
**Problem**: Using map as return type
```go
func InitializeConfig() map[string]interface{} // ❌ Error - map not supported as return type
```

**Solution**: Use struct or other types instead
```go
// Use struct instead
type Config struct {
    Key1 string
    Key2 int
}

func InitializeConfig() Config // ✅ Correct - use struct
```


#### 2. "failed get source from function" Error
**Problem**: Circular dependencies or missing parameter sources
```go
// ❌ Circular dependency
func NewUserService(repo UserRepository) UserService { ... }
func NewUserRepository(service UserService) UserRepository { ... }
```

**Solution**: Break circular dependencies by using interfaces or restructuring

#### 3. "no functions with elsa.Generate calls found"
**Problem**: No functions contain `elsa.Generate()` calls
**Solution**: Ensure at least one function calls `elsa.Generate()`

#### 4. Build Tag Issues
**Problem**: Generated code not included in build
**Solution**: Ensure your build process includes `!elsabuild` files

### Debug Tips

1. **Check build tags**: Ensure files have correct build tags
2. **Verify function signatures**: All constructor functions must be callable
3. **Check parameter types**: Ensure all required types are available
4. **Review dependency chain**: Look for circular dependencies
5. **Validate imports**: Ensure all required packages are imported

## Integration with Build Process

### Go Generate Integration

Add to your source files:

```go
//go:generate go run -mod=mod go.risoftinc.com/elsa/cmd/elsa gen
```

Then run:
```bash
go generate ./...
```

## Performance Considerations

- **Generation time**: Dependency resolution is O(n²) in worst case
- **Build time**: Generated code is optimized for fast compilation
- **Memory usage**: Minimal impact on runtime memory
- **Startup time**: Dependency injection adds minimal overhead

## Migration from Manual Wiring

### Before (Manual)
```go
func main() {
    db := connectDB()
    logger := setupLogger()
    
    userRepo := NewUserRepository(db)
    orderRepo := NewOrderRepository(db)
    
    userService := NewUserService(logger, userRepo)
    orderService := NewOrderService(logger, orderRepo, userService)
    
    userHandler := NewUserHandler(userService)
    orderHandler := NewOrderHandler(orderService)
    
    // Manual wiring continues...
}
```

### After (Elsa Generated)
```go
// 1. Create dependency definition file
//go:build elsabuild
func InitializeServices(db *gorm.DB, logger gologger.Logger) *Dependencies {
    elsa.Generate(RepositorySet, ServiceSet, HandlerSet)
    return nil
}

// 2. Run elsa generate
// 3. Use generated code
func main() {
    deps := InitializeServices(db, logger)
    // All dependencies are ready to use
}
```

This approach provides better maintainability, type safety, and consistency across your application.
